# LeetCode-反转字符串中的元音字母

## 题目描述

给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。

示例 1：

输入：s = "hello"
输出："holle"
示例 2：

输入：s = "leetcode"
输出："leotcede"


提示：

1 <= s.length <= 3 * 105
s 由 可打印的 ASCII 字符组成

## 题解

### 方法一：枚举判断+对撞指针

1、方法描述

（1）基本思想：通过对撞指针的思想，依次找出相对于字符串前后顺序相同的元音字母(在字符串中属于元音字母序列从左到右和从右到左相对顺序相同的两个元音字母，比如从左数第一个元音字母和从右数第一个元音字母），交换这两个元音字母的位置，直至两个指针相遇。

（2）元音字母判断：对字符串中的每一字符进行if判断，判断它们是否是元音字母。

字母表中的元音字母包括小写字母'a'、'e'、'i'、'o'、'u'和大写字母'A'、'E'、'I'、'O'、'U'。

是元音字母：该字符s[i]是上述元音字母中的任意一个（或的关系||）

不是元音字母：该字母s[i]不是上述元音字母的中的任一个（与的关系&&）

（3）字母顺序对换：通过左右指针分别指示从左到右和从右到左的元音字母，然后调用swap函数实现两个元音字母顺序的对换。

①初始化：左指针指向左边第一个字符（left=0）,右指针指向右边第一个字符（right=s.length()-1）

②左指针移动：

​     ⅰ扫描到的字符不是元音字母，左指针右移

​     ⅱ扫描到的字符是元音字母，且已域右边的元音字母交换的位置

③右指针移动：

​     ⅰ扫描到的字符不是元音字母，右指针左移

​     ⅱ扫描到的字符是元音字母，且已域左边的元音字母交换的位置

（4）边界条件

①指针移动：左指针的位置不超过右指针，即left<=right

②扫描的字符在字符串内：左指针不超过右边界（left<s.length()）,右指针不超过左边界（right>=0）

2、具体实现，

```
//版本一：for循环实现
class Solution {
public:
    string reverseVowels(string s) {
        int l,r; //声明变量用作左右指针
         for(l=0,r=s.size()-1;l<=r&&l<s.size()&&r>=0;){ //左指针初始化指向s[0],右指针初始化指向s[s.size()-1]
         //判断左指针所指的字符
    if(s[l]!='a'&&s[l]!='e'&&s[l]!='i'&&s[l]!='o'&&s[l]!='u'&&s[l]!='A'&&s[l]!='E'&&s[l]!='I'&&s[l]!='O'&&s[l]!='U'){//如果不是元音字母，就往右移动左指针
                l++;
                continue; //跳出当前循环，进行下一轮判断（判断左指针的位置是否符合边界条件）
            }
        //判断右指针所指的字符if(s[r]!='a'&&s[r]!='e'&&s[r]!='i'&&s[r]!='o'&&s[r]!='u'&&s[r]!='A'&&s[r]!='E'&&s[r]!='I'&&s[r]!='O'&&s[r]!='U'){ //如果不是元音字母，就往左移动右指针
                r--;
                continue; //跳出当前循环，进行下一轮判断（判断右指针的位置是否符合边界条件）
            }
            swap(s[l++],s[r--]); //交换左右指针所指的两个元音字母，并移动指针
        }
        return s; //返回处理后的字符串
    }
};
//版本二：while循环实现
class Solution {
public:
    string reverseVowels(string s) {
    int left=0;  //初始化左指针的位置
    int right=s.length()-1;  //初始化右指针的位置
    while (left<=right && left<s.length() && (right>= 0)) { //对边界条件进行判断，对字符串中的字符依次进行判断
    //判断左指针所指字符
            if (s[left]!='a' && s[left]!='e' && s[left]!='i' && s[left]!='o' && s[left]!='u' && s[left]!='A' && s[left]!='E' && s[left]!='I' && s[left]!='O' && s[left]!='U') { //当左指针所指字符不是元音字母时左指针右移
                left++;
                 continue;//跳出当前循环，进行下一轮判断（判断左指针的位置是否符合边界条件）
            }
            //判断右指针所指字符
           if (s[right]!='a' && s[right]!='e' && s[right]!='i' && s[right]!='o' && s[right]!='u' && s[right]!='A' && s[right]!='E' && s[right]!='I' && s[right]!='O' && s[right]!='U') { //当右指针所指字符不是元音字母时右指针左移
               right--;
               continue;//跳出当前循环，进行下一轮判断（判断右指针的位置是否符合边界条件）
           }
           swap(s[left++],s[right--]); //交换左右指针所指的两个元音字母的位置，并右移左指针、左移右指针
    }
   return s; //返回字符串
    }

};
```

3、运行结果

![image-20220410182848429](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220410182848429.png)

![image-20220410182655070](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220410182655070.png)

