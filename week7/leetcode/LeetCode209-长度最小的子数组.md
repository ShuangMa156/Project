# LeetCode209-长度最小的子数组

## 题目描述

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0


提示：

1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 105

## 题解

### 解题思路

1、子数组：由数组中的元素构成的数组

​      连续子数组：由数组中连续的元素构成的数组

2、暴力解法：遍历所有的连续子数组[i,j],计算求和，验证sum

时间复杂度:O（n^3）

### 方法一：滑动窗口

1、方法描述

（1）基本思想：用两个指针定位的窗口寻找满足条件的有序子数组

定义两个整型变量作为指针指示数组中的位置，两个指针构成的闭合区域即为原数组的一个子数组。通过判断这两个指针所构成的区域内所有元素的和是否满足要求调整指针的位置，直至寻找结束。

### 方法一：滑动窗口法

1、方法描述：

（1）基本思想：通过定义了两个指针指示数组中元素的位置，并求解这连个

（2）子数组结构：由两个指针构成的连续闭合区域

初始化：没有元素，即左指针left=0,右指针right=-1

（3）窗口移动：通过比较当前子数组的和与目标值的大小关系，对窗口的大小和位置进行调整

当前数组和小于目标值------>窗口扩大（使子数组的求和值满足目标值所要求的的大小）------>右边界右移

当前数组和大于等于目标值----->窗口缩小（在“子数组的求和值满足目标值所要求的的大小的条件下”，尽量缩短子数组的长度）------>左边界右移

子数组长度更新：如果子数组的求和值大于目标值，则求解子数组的长度（右边界位置-左边界位置+1，即right-left+1）,并取当前子数组长度（right-left+1）与原子数组长度的最小值(len)

（4）边界条件：左边界的位置不超过原数组的范围，右边界的位置不超过原数组的范围

（5）初始化：

左边界的位置：指向数组中第一个元素所在的位置，即left=0

右边界的位置：指向数组中不存在的位置,即right=-1

窗口长度：一个不可能的值，即len=nums.size()+1

（6）返回值：

无解：子数组的长度为整个数组的长度加1（不可能存在），即右边界的位置未被更更新，返回0

有解：返回子数组长度len

2、具体实现：

```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum=0; //初始化子数组和
        int left=0; //初始化左边界位置，nums[left..right]为滑动窗口，初始时窗口中不包含任何元素
        int right=-1;  //初始化右边界位置
        int len=nums.size()+1; //初始化为最大值
        while (left<nums.size()) { //当左边界仍在数组中时
            if (right+1<nums.size() && sum<target) { //当前子数组的求和结果小于目标值，则右移右边界（注意数组越界问题，要保证右边界移动后仍在原数组中）
                right++; //窗口的右边界拓展
                sum+=nums[right]; //计算右边界右移后子数组的求和结果
            }
            else { //当前子数组的求和结果大于目标值，则右移左边界，并计算左边界右移后的求和结果
                sum-=nums[left++];
            }
            if (sum>=target) { //当子数组的求和结果大于目标值时，更新字数长度
                len=min(len,right-left+1); //窗口为[left..right] (左闭右闭)，所以子数组的长度为（right-left+1），取原数组长度和当前数组长度中的较小者
            }
        }
        if (len==nums.size()+1) { //如果无解，则长度不会被更新，返回0
            return 0;
        }
        return len; //返回数组长度
    }
};
//时间复杂度:O(n)
//空间复杂度：O(1)
```

3、运行结果：

![image-20220410201455849](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220410201455849.png)

