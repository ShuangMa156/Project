# LeetCode88-合并两个有序数组

## 题目描述

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2：

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
示例 3：

输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。


提示：

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-10^9 <= nums1[i], nums2[j] <= 10^9

## 题解

### 方法一：调用sort函数实现排序

1、方法描述

（1）基本思想：现将两个数组的元素合并为一个数组，然后利用sort函数直接得到合并后数组的非递减排序结果。

（2）合并数组：由于nums1中[m..n-1]位置上的元素值均为0，所以将nums2数组中的元素拷贝到nums1中的这些位置，不会影响元素组。

for循环遍历，通过下标索引，将数组nums2的元素复制到nums1中

（3）非递减顺序排列结果：调用C++标准库中的sort函数

C++ STL 标准库中的 sort() 函数，本质就是一个模板函数，该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序。

**sort() 函数是基于快速排序实现的**，sort() 函数无法保证值相同的元素排序后的相对位置不发生改变

sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：

①容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持。

②如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持`<`小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；

③sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。

![image-20220315093804571](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220315093804571.png)

2、具体实现

```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    for (int i=0;i<n;++i) {
      nums1[m+i]=nums2[i]; //将数组nums2中的元素拷贝到数组nums1中
    }
    sort(nums1.begin(),nums1.end()); //从数组nums1的开始位置nums1。begin()到结束位置nums1.end()，对所有元素进行排序
    }
};
```

3、运行结果

![image-20220312231353892](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220312231353892.png)

### 方法二：利用归并排序的思想，合并两个有序的数组

1、方法描述

（1）基本思想：借助于辅助数组，按照归并的思想，依次从两个数组中挑选一个值较小的，知道排列完所有元素

（2）归并数组：从两个数组中依次挑选出值较小的元素放到新的数组中，知道有一个数组的所有元素都已放到新数组中

比较的条件：两个数组当前均还有未处理的元素，即 i1<m && i2<n

元素比较：若数组nums1中的元素较小（nums1[i1] <= nums2[i2]），则将nums1中的元素放到临时数组中；若数组nums1中的元素较小（nums1[i1] > nums2[i2]），则将nums2中的元素放到临时数组中

剩余元素处理：当有一个数组的所有元素都已放置到临时数组中时，则将另一个数组中的剩余元素直接拷贝到临时数组。

（3）结果输出：将临时数组中按照非降序归并后的所有元素拷贝到数组nums1中

2、具体实现

```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i1=0; //记录数组nums1中当前处理的元素
    int i2=0; //记录数组nums2中当前处理的元素
    vector<int> temp; //定义临时数组用于保存归并结果
    while (i1<m && i2<n) { //比较两个数组中的元素
        if (nums1[i1] <= nums2[i2]) { //nums1中的元素值较小
            temp.push_back(nums1[i1++]);
        } else {
            temp.push_back(nums2[i2++]); //nums2中的元素值较小
        }
    } 
    while (i1<m) { //将nums1中剩余的元素直接拷贝到临时数组
        temp.push_back(nums1[i1++]);
    }
    while (i2<n) { //将nums2中剩余的元素直接拷贝到临时数组
        temp.push_back(nums2[i2++]);
    }
    for (int i=0;i<temp.size();++i) { //将临时数组中的元素拷贝到数组nums1中
        nums1[i]=temp[i];
    }
    }
};
```

3、运行结果

![image-20220313164805913](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220313164805913.png)

